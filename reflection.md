# Project Reflection Points

## What makes a page a good candidate for getStaticProps versus getServerSideProps?
In modern web development, one of the common decisions developers face is whether to generate pages ahead of time or render them on the server as requests come in. This usually boils down to a trade-off between speed, how current the data needs to be, and whether the content should change depending on who’s looking at it. Next.js offers two built-in approaches to handle this: `getStaticProps` and `getServerSideProps`. Each serves a different purpose, and picking the right one can have a big impact on how your app performs and how much effort you spend keeping it running smoothly.

With `getStaticProps`, the key idea is that the page gets built just once, during the build step. So, the result is a static HTML file that can be stored on a CDN and instantly served to anyone visiting that page. This method is incredibly fast because there's no server processing when the request is made; the HTML is already ready to go. It's perfect for things like blog posts, product landing pages, or documentation, where the content doesn’t change often. If your content does need to be updated every so often, you can use Incremental Static Regeneration (ISR). This feature allows you to tell Next.js to rebuild certain pages in the background after a set period, so your users still get a fast experience while the data stays reasonably fresh.

On the other hand, `getServerSideProps` is used when the data needs to be completely up to date on every visit. Instead of generating the page ahead of time, the server fetches the latest data and builds the page on the spot for each user. That way, the visitor always sees the most current version. This is especially useful for things like admin dashboards, live stats, or pages where content depends on who is logged in. Because the request goes through the server every time, you can also make use of cookies or headers to personalize the content.

The downside to this approach is that it tends to be slower than static generation, since the server has to do more work on every request. It also puts more strain on your infrastructure and makes it harder to take advantage of the scalability and global distribution that CDNs offer. That’s why it’s generally a good idea to reserve `getServerSideProps` for pages that truly need fresh or user-specific content and lean on `getStaticProps` for everything else.

So, how do you choose between the two? It helps to ask a few questions: Does the page need to show up-to-the-minute data? Is the content the same for every visitor, or does it change based on who they are? And how important is speed for that particular page? If your answers point to needing consistent, fresh data or user-specific views, then `getServerSideProps` makes sense. But if your content is relatively stable and shared across all users, then `getStaticProps` can give you much faster load times and better scalability with fewer moving parts.

## How does ISR differ from traditional SSG?
Traditional static site generation (SSG) follows a very straightforward model: all pages are pre-built when you run your build process, and those HTML files are what users see every time they visit your site. Once that build is complete, the content on those pages stays the same until you trigger another rebuild. For smaller websites or content that rarely changes like documentation, portfolios, or marketing pages, this method is simple and efficient. It's fast, reliable, and pages can be served instantly from a content delivery network (CDN) without involving the server.

However, problems start to show up as the size of your site grows or your content updates more frequently. For example, a blog with hundreds of posts or an e-commerce site with constantly changing product information would need to rebuild everything, even for just one minor update. That slows things down and makes deployments more complex.

This is where Incremental Static Regeneration, or ISR, comes in. ISR takes the best parts of SSG, like speed and scalability, but removes the need to rebuild the whole site every time something changes. Instead of regenerating everything at once, ISR allows you to update individual pages after your site has already been deployed. You can specify how often each page should be refreshed by setting a revalidate time. When someone visits a page and that page is due for an update, Next.js serves the existing static version immediately and quietly starts a background process to regenerate the page. Once that regeneration is finished, the new version automatically replaces the old one. No rebuild, no downtime, and no one ever sees a broken or outdated page.

On top of that, ISR also supports triggering updates manually using something called on-demand revalidation. This is especially useful when working with a CMS. For example, when an editor publishes a new blog post, the CMS can send a request to your site, telling it to regenerate the relevant pages right away. That means content can be updated instantly without having to wait for a scheduled revalidation time.

In essence, traditional SSG is like taking a snapshot of your site and sticking with it until you’re ready to take a new one. ISR, on the other hand, gives you a way to keep your static pages up to date automatically or on demand, without losing any of the performance benefits. It’s a more flexible, efficient solution for websites that need to stay fresh while still loading fast.

## What happens during fallback states?
When building web applications with Next.js, especially ones that include dynamic routes, there comes a point where you need to decide how to handle pages that weren’t known or generated during the build process. That’s where the `fallback` option inside `getStaticPaths` becomes important. It lets you control what happens when someone visits a path that wasn’t pre-rendered. The behavior changes depending on how you configure this option, and each setting has its own set of implications for performance, user experience, and scalability.

If you set fallback to `false`, you’re essentially telling Next.js that the list of paths you’ve provided at build time is complete and final. Only those pages will be generated, and any route not on that list will simply return a 404 page. That’s fine if your content doesn’t change often or you already know every route in advance. It’s predictable and clean, but it also means that adding any new page later on will require a full site rebuild. For smaller sites or tightly controlled content, this limitation might not matter, but it becomes a bottleneck if new content is added frequently or by users outside the development team.

Things get more flexible when you switch to `fallback: true`. In this mode, Next.js doesn’t immediately reject unknown paths. Instead, when someone visits a page that wasn’t pre-generated, the app displays a temporary fallback state (often a loading spinner or some skeleton layout) while the server fetches the necessary data and builds the page in real-time. Once it’s ready, the full content replaces the placeholder on the screen, and the newly built page gets cached. From that point forward, any future visits to the same path are as fast as any statically served page. This approach works well if your site is growing often or if content is created dynamically, such as blog posts, user profiles, or product listings.

Then there’s the third option: `fallback: "blocking"`. This one behaves differently. Instead of serving a loading state to the user while building the page, Next.js waits until the data is fetched and the HTML is fully rendered before sending anything back to the browser. In practice, the user won’t see a spinner, they’ll just wait a bit longer for the first request; but the page arrives fully rendered and ready to interact with. Like with `true`, the page is cached for future use. This option is useful when you want to avoid showing loading placeholders but still want your app to generate pages on demand.

What all these fallback modes have in common is that they let your site expand naturally without you having to regenerate the entire app every time new content appears. Whether you show a loading screen first (`true`), hold the request until the page is ready (`"blocking"`), or stick with a fixed set of pages (`false`), your decision will depend on how often your content changes, how much control you need over the user experience, and how much time you're willing to spend rebuilding.